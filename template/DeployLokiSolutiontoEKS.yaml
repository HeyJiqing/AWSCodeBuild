AWSTemplateFormatVersion: '2010-09-09'
Description: CodeBuild Project for Container Log Sloution (PLG) Deployment
Resources:
  CodebuildIAMRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - CodeBuildIAMRole
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
      ManagedPolicyArns:
        - !Ref 'CodeBuildIAMPolicy'
  CodeBuildIAMPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: !Join
        - '-'
        - - CodeBuildIAMPolicy
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Description: Managed policy for CodeBuild
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - codebuild:*
              - eks:*
              - iam:*
              - logs:*
              - cloudformation:*
            Effect: Allow
            Resource: '*'
  ServiceAccountLokiIAMRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - ServiceAccountLokiIAMRole
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      AssumeRolePolicyDocument: !Sub |
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Federated": "arn:aws:iam::${AWS::AccountId}:oidc-provider/${ClusterOIDCURL}"
              },
              "Action": "sts:AssumeRoleWithWebIdentity",
              "Condition": {
                "StringEquals": {
                  "${ClusterOIDCURL}:sub": "system:serviceaccount:loki:loki",
                  "${ClusterOIDCURL}:aud": "sts.amazonaws.com"
                }
              }
            }
          ]
        }
      ManagedPolicyArns:
        - !Ref 'ServiceAccountLokiIAMPolicy'
  ServiceAccountLokiIAMPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: !Join
        - '-'
        - - ServiceaccountLokiIAMPolicy
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Description: Managed policy for ServiceAccount Loki
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - dynamodb:BatchGetItem
              - dynamodb:BatchWriteItem
              - dynamodb:UntagResource
              - dynamodb:PutItem
              - dynamodb:DeleteItem
              - dynamodb:ListTagsOfResource
              - dynamodb:Query
              - dynamodb:UpdateItem
              - dynamodb:DeleteTable
              - dynamodb:CreateTable
              - dynamodb:TagResource
              - dynamodb:DescribeTable
              - dynamodb:GetItem
              - dynamodb:UpdateTable
              - dynamodb:ListTables
              - dynamodb:Query
              - s3:PutObject
              - s3:GetObject
              - s3:ListBucket
              - s3:DeleteObject
            Effect: Allow
            Resource: '*'
  CleanupS3LambdaExecutionIAMRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - CleanupS3LambdaExecutionIAMRole
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - !Ref 'CleanupS3LambdaExecutionIAMPolicy'
  CleanupS3LambdaExecutionIAMPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: !Join
        - '-'
        - - CleanupS3LambdaExecutionIAMPolicy
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Description: Managed policy for CodeBuild
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - '*'
            Effect: Allow
            Resource: '*'
  ClusterOIDCLambdaExecutionIAMRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      RoleName: !Join
        - '-'
        - - ClusterOIDCLambdaExecutionIAMRole
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
            - Effect: Allow
              Action:
              - eks:DescribeCluster
              Resource: !Sub "arn:aws:eks:${AWS::Region}:${AWS::AccountId}:cluster/${EKSClusterName}"
            - Effect: Allow
              Action:
              - iam:*OpenIDConnectProvider*
              Resource: "*"
            - Effect: Allow
              Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
              Resource: "*"
  S3BucketLoki:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join
        - '-'
        - - logs-chunks
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
  DynamoDBTableLoki:
    Type: AWS::DynamoDB::Table
    Properties:
      TableClass: STANDARD
      TableName: !Join
        - '-'
        - - log-index
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        -
          AttributeName: h
          AttributeType: S
        -
          AttributeName: r
          AttributeType: B
      KeySchema:
        -
          AttributeName: h
          KeyType: HASH
        -
          AttributeName: r
          KeyType: RANGE
  CodeBuildProjectDeployPLG:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Join
        - '-'
        - - deploy-plg-solution
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Description: Deploy Conatiner Log Solution(PLG) to an Existing EKS Cluster
      Cache:
        Type: NO_CACHE
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        ComputeType: BUILD_GENERAL1_SMALL
        EnvironmentVariables:
          - Name: REGION
            Type: PLAINTEXT
            Value: !Ref 'AWS::Region'
          - Name: LOKI_BUCKET_NAME
            Type: PLAINTEXT
            Value: !Ref 'S3BucketLoki'
          - Name: LOKI_DDB_TABLE_NAME
            Type: PLAINTEXT
            Value: !Ref 'DynamoDBTableLoki'
          - Name: EKS_CLUSTER_NAME
            Type: PLAINTEXT
            Value: !Ref 'EKSClusterName'
          - Name: SOURCE_CODE_VENDOR
            Type: PLAINTEXT
            Value: !Ref 'SourceCodeVendor'
          # - Name: SAPOLICY
          #   Type: PLAINTEXT
          #   Value: !Ref 'ServiceAccountPolicy'
          # - Name: DOWNLOAD_URL
          #   Type: PLAINTEXT
          #   Value: !Ref 'EksctlDownloadUrl'
          - Name: EXPOSE_TYPE
            Type: PLAINTEXT
            Value: !Ref 'GrafanaExposeType'
          - Name: CHUNK_TARGET_SIZE
            Type: PLAINTEXT
            Value: !Ref 'ChunkTargetSize'
          - Name: CHUNK_IDLE_PERIOD
            Type: PLAINTEXT
            Value: !Ref 'ChunkIdlePeriod'
          - Name: SERVICE_ACCOUNT_IAM_ROLE_ARN
            Type: PLAINTEXT
            Value: !GetAtt ServiceAccountLokiIAMRole.Arn
        Image: aws/codebuild/amazonlinux2-x86_64-standard:3.0
        ImagePullCredentialsType: CODEBUILD
        PrivilegedMode: false
        Type: LINUX_CONTAINER
      ServiceRole: !GetAtt CodebuildIAMRole.Arn
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            install:
              commands:
                - aws eks update-kubeconfig --region $REGION --name $EKS_CLUSTER_NAME
                # - wget $DOWNLOAD_URL
                # - tar zxf eksctl_Linux_amd64.tar.gz
                # - chmod +x eksctl && mv eksctl /usr/local/bin/
                # - eksctl version
                - curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.21.2/2021-07-05/bin/linux/amd64/kubectl
                - chmod +x kubectl && mv kubectl /usr/local/bin/
                - kubectl version
                # - kubectl create ns loki
                - git clone https://$SOURCE_CODE_VENDOR.com/HeyJiqing/AWSCodeBuild.git
                - cd AWSCodeBuild
            pre_build:
              commands:
                # - eksctl utils associate-iam-oidc-provider --region $REGION --cluster $EKS_CLUSTER_NAME --approve
                # - eksctl create iamserviceaccount --region $REGION --cluster $EKS_CLUSTER_NAME --namespace loki --name loki --attach-policy-arn $SAPOLICY --override-existing-serviceaccounts --approve
                - sed -i -e "s/REGION/$REGION/g" -e "s/LOKI_BUCKET_NAME/$LOKI_BUCKET_NAME/g" -e "s/LOKI_DDB_TABLE_NAME/$LOKI_DDB_TABLE_NAME/g" -e "s/CHUNK_TARGET_SIZE/$CHUNK_TARGET_SIZE/g" -e "s/CHUNK_IDLE_PERIOD/$CHUNK_IDLE_PERIOD/g" -e "s/SERVICE_ACCOUNT_IAM_ROLE_ARN/$SERVICE_ACCOUNT_IAM_ROLE_ARN/g" yaml/plg-deploy.yaml
            build:
              commands:
                - cat yaml/plg-deploy.yaml && cat yaml/$EXPOSE_TYPE.yaml
            #     - kubectl apply -f yaml/plg-deploy.yaml
            #     - kubectl apply -f yaml/$EXPOSE_TYPE.yaml
            #     - kubectl -n loki get all
            # post_build:
            #   commands:
            #     - sleep 15
                # - if [ "$EXPOSE_TYPE" = "NodePort" ]; then echo && echo "=========================Grafana Login Info=========================" && echo "Grafana Login Username:"`kubectl -n loki get secrets loki-grafana -o jsonpath={.data.admin-user} |base64 -d` && echo "Grafana Login Password:"`kubectl -n loki get secrets loki-grafana -o jsonpath={.data.admin-password} |base64 -d` && echo "Grafana Login Address:http://"`kubectl get node -o wide |awk '{print $7}' |awk 'NR==2'`':'`kubectl -n loki get svc loki-grafana -o jsonpath={.spec.ports[0].nodePort}` && echo "=========================Grafana Login Info========================="; else echo && echo "=========================Grafana Login Info=========================" && echo "Grafana Login Username:"`kubectl -n loki get secrets loki-grafana -o jsonpath={.data.admin-user} |base64 -d` && echo "Grafana Login Password:"`kubectl -n loki get secrets loki-grafana -o jsonpath={.data.admin-password} |base64 -d` && echo "Grafana Login Address:http://"`kubectl -n loki get ingress loki-grafana -o jsonpath={.status.loadBalancer.ingress[0].hostname}` && echo "=========================Grafana Login Info========================="; fi
  CleaupS3OnDelete:
    Type: Custom::CustomResource
    Properties:
      ServiceToken: !GetAtt CleanupS3LambdaFunction.Arn
      BucketName: !Ref 'S3BucketLoki'
  CleanupS3LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.7
      Handler: "index.lambda_handler"
      MemorySize: 128
      Role: !GetAtt CleanupS3LambdaExecutionIAMRole.Arn
      Timeout: 60
      FunctionName: !Join
        - '-'
        - - cleanup-bucket-on-delete
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Code: 
        ZipFile: 
          !Sub |
            import json, boto3, logging
            import cfnresponse
            logger = logging.getLogger()
            logger.setLevel(logging.INFO)
            def lambda_handler(event, context):
                logger.info("event: {}".format(event))
                try:
                    bucket = event['ResourceProperties']['BucketName']
                    logger.info("bucket: {}, event['RequestType']: {}".format(bucket,event['RequestType']))
                    if event['RequestType'] == 'Delete':
                        s3 = boto3.resource('s3')
                        bucket = s3.Bucket(bucket)
                        for obj in bucket.objects.filter():
                            logger.info("delete obj: {}".format(obj))
                            s3.Object(bucket.name, obj.key).delete()
                    sendResponseCfn(event, context, cfnresponse.SUCCESS)
                except Exception as e:
                    logger.info("Exception: {}".format(e))
                    sendResponseCfn(event, context, cfnresponse.FAILED)
            def sendResponseCfn(event, context, responseStatus):
                responseData = {}
                responseData['Data'] = {}
                cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")
  ClusterOIDCURL:
    Type: Custom::ClusterOIDCURL
    Properties:
      ServiceToken: !GetAtt ClusterOIDCURLFunction.Arn
      ClusterName: !Ref EKSClusterName
  ClusterOIDCURLFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.7
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt ClusterOIDCLambdaExecutionIAMRole.Arn
      Timeout: 30
      FunctionName: !Join
        - '-'
        - - get-cluster-oidc-url
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          eks = boto3.client("eks")
          def lambda_handler(event, context):
            responseData = {}
            if event['RequestType'] == 'Delete':
              responseData['Reason'] = "Success"
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, "")
            else:
              try:
                cluster_name = event['ResourceProperties']['ClusterName']
                response = eks.describe_cluster(name=cluster_name)
                cluster_oidc_url = response['cluster']['identity']['oidc']['issuer']
                without_protocol = cluster_oidc_url.replace('https://', '')
                responseData['Reason'] = "Success"
                responseData['Url'] = without_protocol
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, without_protocol)
              except Exception as e:
                responseData['Reason'] = str(e)
                cfnresponse.send(event, context, cfnresponse.FAILED, responseData, "")
  ClusterOIDCProvider:
    Type: Custom::ClusterOIDCProvider
    Properties:
      ServiceToken: !GetAtt ClusterOIDCProviderFunction.Arn
      ClusterOIDCURL: !Ref ClusterOIDCURL
      AccountID: !Ref AWS::AccountId
      AWSPartition: !Ref AWS::Partition
  ClusterOIDCProviderFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.7
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt ClusterOIDCLambdaExecutionIAMRole.Arn
      Timeout: 30
      FunctionName: !Join
        - '-'
        - - create-cluster-oidc-provider
          - !Ref 'AWS::AccountId'
          - !Ref 'AWS::Region'
      Code:
        ZipFile: |
          import boto3
          from botocore.exceptions import ClientError
          import json
          import cfnresponse
          iam = boto3.client("iam")
          def lambda_handler(event, context):
            data = {}
            try:
              cluster_oidc_url = event['ResourceProperties']['ClusterOIDCURL']
              account_id = event['ResourceProperties']['AccountID']
              partiton = event['ResourceProperties']['AWSPartition']
              if event['RequestType'] == 'Create':
                with_protocol = "https://" + cluster_oidc_url
                oidc_provide_arn = "arn:{0}:iam::{1}:oidc-provider/{2}".format(partiton, account_id, cluster_oidc_url)
                # arn:aws:iam::859017966381:oidc-provider/oidc.eks.ap-southeast-1.amazonaws.com/id/769D47CB1413F168E93FBCCC7A773215
                try:
                  res = iam.get_open_id_connect_provider(OpenIDConnectProviderArn=oidc_provide_arn)
                  if res.get('Url') == cluster_oidc_url:
                    data["Reason"] = "Provider already exist, skip"
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, data, oidc_provide_arn)
                    return 0
                except Exception as e:
                  print("oidc provider  not found")
                issuer_thumbprint = '9e99a48a9960b14926bb7f3b02e22da2b0ab7280'
                resp = iam.create_open_id_connect_provider(Url=with_protocol,ClientIDList=['sts.amazonaws.com'],ThumbprintList=[issuer_thumbprint])
                provider_arn = resp['OpenIDConnectProviderArn']
                data["Reason"] = "Provider with ARN " + provider_arn + " created"
                cfnresponse.send(event, context, cfnresponse.SUCCESS, data, provider_arn)
              elif event['RequestType'] == 'Delete':
                provider_arn = event["PhysicalResourceId"]
                data["Reason"] = "Provider with ARN " + provider_arn
                cfnresponse.send(event, context, cfnresponse.SUCCESS, data, provider_arn)
            except Exception as e:
              data["Reason"] = "Cannot " + event['RequestType'] + " Provider" + str(e)
              cfnresponse.send(event, context, cfnresponse.FAILED, data, "")
Parameters:
  EKSClusterName:
    Type: String
    Description: The EKS Cluster which PLG solution deploy on
  GrafanaExposeType:
    Type: String
    Default: NodePort
    AllowedValues:
      - NodePort
      - Ingress
    Description: Choose the way to expose Grafana, NodePort(EC2 should have public ip) or Ingress(already installed aws alb controller)
  SourceCodeVendor:
    Type: String
    Default: github
    AllowedValues:
      - github
      - gitee
    Description: Use Gitee(China) or GitHub(Global) to pull source code
  # EksctlDownloadUrl:
  #   Type: String
  #   Default: https://github.com/weaveworks/eksctl/releases/download/v0.92.0/eksctl_Linux_amd64.tar.gz
  #   AllowedValues:
  #     - https://github.com/weaveworks/eksctl/releases/download/v0.92.0/eksctl_Linux_amd64.tar.gz
  #     - https://gitee.com/HeyJiqing/AWSCodeBuild/attach_files/1022472/download/eksctl_Linux_amd64.tar.gz
  #   Description: Use Gitee(China) or GitHub(Global) to download eksctl binary
  ChunkTargetSize:
    Type: Number
    Default: 1572864
    Description: How long chunks should sit in-memory with no updates before being flushed if they don't hit the max block size.
  ChunkIdlePeriod:
    Type: String
    Default: 30m
    Description: A target _compressed_ size in bytes for chunks. 
Outputs:
  CodeBuildIAMRoleARN:
    Description: Role shoule be added to Kubernetes ConfigMap 'aws-auth' 
    Value: !GetAtt CodebuildIAMRole.Arn
  ClusterOIDCURL:
    Description: The OpenID Connect URL (without protocol)
    Value: !Ref ClusterOIDCURL
  ClusterOIDCProvider:
    Description: The ARN of the OIDCProvider
    Value: !Ref ClusterOIDCProvider